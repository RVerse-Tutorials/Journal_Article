---
title: "Influential Years Analysis: only past catch"
output:
  pdf_document: default
  word_document: default
header-includes: \usepackage[labelformat=empty]{caption}
---

```{r child = 'setup.Rmd'}
```

```{r funs, echo=FALSE}
library(mgcv)
library(SardineForecast)
library(ggplot2)
library(MARSS)
library(grid)

ret <- function(mod, resfun){
    if(resfun=="aic") return(AIC(mod))
    if(resfun=="aicc") return(SardineForecast:::AICc(mod))
    if(resfun=="loo") return(SardineForecast:::loogam(mod)$RMSE)
    if(resfun=="looMd") return(SardineForecast:::loogam(mod)$MdAE)
    if(resfun=="r2"){
      if(class(mod)[1]=="gam") return(summary(mod)$r.sq)
      if(class(mod)[1]=="lm") return(summary(mod)$adj.r.squared)
    } 
  }
rmyr <- c(1986, 1994)
Palette4 <- c("#000000", "#999999", "#F0E442", "#D55E00")
mods <- c("base", "lin(Jul-Sep(t-1))", "gam(Jul-Sep(t-1))", "lin(Jul-Sep(t-1)), lin(Jul-Sep(t-2))", "gam(Jul-Sep(t-1)), gam(Jul-Sep(t-2))", "lin(Oct-Mar(t-1))", "gam(Oct-Mar(t-1))", "lin(Oct-Mar(t-1)), lin(Oct-Mar(t-2))", "gam(Oct-Mar(t-1)), gam(Oct-Mar(t-2))", "lin(Jul-Sep(t-1)), lin(Oct-Mar(t-2))", "gam(Jul-Sep(t-1)), gam(Oct-Mar(t-2))", "lin(Oct-Mar(t-1)), lin(Jul-Sep(t-2))", "gam(Oct-Mar(t-1)), gam(Jul-Sep(t-2))", "lin(Oct-Mar(t-1)), lin(Jul-Sep(t-1))", "gam(Oct-Mar(t-1)), gam(Jul-Sep(t-1))")
modelset <- mods[c(2,3,5,6,7,9, 11, 13, 15)]
modelset <- mods[-1]
modelset <- mods[seq(3,15,2)]
modelset <- mods[2:13]
aspr <- 3/3
figh <- 3.5

dforig=data.frame(Year=respdat$Year, 
              spawners0=respdat$spawners0, spawners1=respdat$spawners1, spawners2=respdat$spawners2, 
              nspawners0=respdat$nspawners0, nspawners1=respdat$nspawners1, 
               nspawners2=respdat$nspawners2)
dforig <- na.omit(dforig)

```

## Validation of the Jul-Sep landings base models

To evaluate the base model for the Jul-Sep landings using only prior catch as covariates, three types of models were fit. The first two were GAM and linear models with Jul-Sep and Oct-Mar in the prior season only or prior season and two seasons prior as covariates:
\begin{align*}
\text{GAM t-1}: S_t = \alpha + s(c_{t-1}) + e_t \\
\text{Linear t-1}: S_t = \alpha + \beta c_{t-1} + e_t \\
\text{GAM t-1, t-2}: S_t = \alpha + s(c_{t-1}) + s(d_{t-2}) + e_t \\
\text{Linear t-1, t-2}: S_t = \alpha + \beta c_{t-1} + d_{t-2} + e_t
\end{align*}
where $c_{t-1}$ was either $S_{t-1}$ (Jul-Sep landings in prior season) or $N_{t-1}$ (Oct-Mar landings in prior season) and $d_{t-2}$ was the same but 2 seasons prior.

These types of models do not allow the model parameters (the intercept $\alpha$ and effect parameter $\beta$) to vary in time.  The second type of models were dynamic linear models (DLMs). DLMs allow the parameters to evolve in time. Two types of DLMs were used, an intercept only model where the intercept $\alpha$ evolves and a linear model where the effect parameter $\beta$ is allowed to evolve:
\begin{align*}
\text{DLM intercept only}: S_t = \alpha_t + e_t \\
\text{DLM intercept and slope}: S_t = \alpha_t + \beta_t t + e_t \\
\text{DLM intercept and effect}: S_t = \alpha_t + \beta_t c_{t-1} + e_t
\end{align*}

In addition to the GAM, linear and DLM models, three null models were included in the tested model sets: 
\begin{align*}
\text{intercept only}: S_t = \alpha + e_t \\
\text{intercept and prior catch}: S_t = \alpha_t + S_{t-1} + e_t \\
\text{prior catch only}: S_t = S_{t-1} + e_t
\end{align*}
The 'intercept only' is a flat level model. The 'prior catch only' simply uses the prior value of the time series (in this case landings) as the prediction and is a standard null model for prediction. The 'intercept and prior catch' combines these two null models.

The models were fit to the 1956-2015 landings (full data) and 1984-2015 (data that overlap the environmental covariates). 

The model performance is shown as the leave-one-out (LOO) one-step-ahead prediction errors. The data point $t$ is omitted and the model is fit to the remaining data. This is the LOO model. The prediction error is the data point $t$ minus the predited value for data point $t$. This is repeated for all data points $t$. The AICc values for the models are also shown. AICc is based on the log-likelihood which is calculated from the one-step-ahead prediction errors for the full data (no data left out).

### Results

Figures 1D and 2D show the $\Delta$AICc values for the model set.

The Figure 1D shows the one step ahead predictions for the models broken out in the three categories: GAM, linear, and DLM.

that with any year left out, the set of models that has the lowest AIC was always GAM with Oct-Mar and Jul-Sep landings in the prior season or GAM with only Oct-Mar landings in the prior season. There were cases where deleting a year removed one of these two from the 'best' category, but they were still in the 'competitive category. However, when we look at the Leave-one-out predictive performance (Figure 2D), we see that the GAM with Oct-Mar and Jul-Sep landings in the prior season is better than the GAM with only Oct-Mar landings---except when 1995 or 1987-88 are left out. 

This suggests that the better predictive performance is due to better prediction of 1994-95 or 1987-8.  The covariate analysis also indicated that 1994-95 have a strong influence on the selected models. This is not entirely surprising since 1994 was a year of a severe decline and 1995 a year when the landings rebounded.  The analysis was repeated with 1994 and 1995 removed (Figure 3D and 4D). With these 2 years removed, the GAM with Oct-Mar landings in prior season only is the model with lowest AIC and LOO predictive performance regardless of which year is removed. Thus, the GAM with Oct-Mar landings in the prior season only was choosen as the base model for Jul-Sep landings.

It should be noted that none of the models has a particularly high adjusted R$^2$ (Figure 5D). The values are generally less than 0.3. The Jul-Sep landings tend to be highly variable and not related to the catch in prior years. Jul-Sep is during the monsoon during which fishing is not always possible due to sea-state and there is a 6-week fishing ban during this time.

```{r table-appD-resinf, echo=FALSE}
resinf <- function(rmyr=1900, resfun="aic", data=dat.nonspawners, resp="spawners0"){
  
  covnames=c("nspawners1", "spawners1",
             "nspawners2", "spawners2")
  modnames=c("Oct-Mar(t-1)", "Jul-Sep(t-1)",
             "Oct-Mar(t-2)", "Jul-Sep(t-2)")
  
  tests=list(c(2),c(2,4),c(1),c(1,3),c(2,3), c(1,4))
  ## SPAWNERS
  dat=data
  dat[[resp]][dat$Year%in%rmyr]=NA
  dat$resp = dat[[resp]]
  m0 = gam(resp ~ 1, data=dat)
  res = data.frame(model="null intercept", None=ret(m0, resfun))
  
  dat$cov1=dat[[str_replace(resp,"0","1")]]
  m0 = gam(resp ~ offset(cov1), data=dat)
  tmp = data.frame(model="null offset w intercept",None=ret(m0, resfun))
  res = rbind(res, tmp)
  
  m0 = lm(resp ~ -1 + offset(cov1), data=dat)
  tmp = data.frame(model="null offset only",None=ret(m0, resfun))
  res = rbind(res, tmp)
  
  for(val in tests){
    if(length(val)==1){
      dat$cov1=dat[[covnames[val[1]]]]
      m0 = gam(resp ~ cov1, data=dat)
      tmp = data.frame(model=paste0("lin(", modnames[val[1]],")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
      m0 = gam(resp ~ s(cov1, sp=0.6), data=dat)
      tmp = data.frame(model=paste0("gam(", modnames[val[1]],")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
    }else{
      dat$cov1=dat[[covnames[val[1]]]]
      dat$cov2=dat[[covnames[val[2]]]]
      m0 = gam(resp ~ cov1 + cov2, data=dat)
      tmp = data.frame(model=paste0("lin(", modnames[val[1]], "), lin(", modnames[val[2]], ")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
      m0 = gam(resp ~ s(cov1,sp=0.6) + s(cov2,sp=0.6), data=dat)
      tmp = data.frame(model=paste0("gam(", modnames[val[1]], "), gam(", modnames[val[2]], ")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
    }
  }
  
  for(yr in min(dat$Year):max(dat$Year)){
    bad = yr
    dat2=dat
    dat2$resp[dat$Year%in%bad]=NA
    m0 = gam(resp ~ 1, data=dat2)
    #colname will be renamed below from None to year deleted
    tmpres = data.frame(model="null intercept",None=ret(m0, resfun))
    
    dat2$cov1=dat[[str_replace(resp,"0","1")]]
    m0 = gam(resp ~ offset(cov1), data=dat2)
    #colname will be renamed below from None to year deleted
    tmp = data.frame(model="null offset w intercept",None=ret(m0, resfun))
    tmpres = rbind(tmpres, tmp)
    
    m0 = lm(spawners0 ~ -1 + offset(cov1), data=dat2)
    #colname will be renamed below from None to year deleted
    tmp = data.frame(model="null offset only",None=ret(m0, resfun))
    tmpres = rbind(tmpres, tmp)
    
    for(val in tests){
      if(length(val)==1){
        dat2$cov1=dat[[covnames[val[1]]]]
        m0 = gam(resp ~ cov1, data=dat2)
        tmp = data.frame(model=paste0("lm(", modnames[val[1]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
        m0 = gam(resp ~ s(cov1, sp=0.6), data=dat2)
        tmp = data.frame(model=paste0("gam(", modnames[val[1]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
      }else{
        dat2$cov1=dat[[covnames[val[1]]]]
        dat2$cov2=dat[[covnames[val[2]]]]
        m0 = gam(resp ~ cov1 + cov2, data=dat2)
        tmp = data.frame(model=paste0("lm(", modnames[val[1]], ", ", covnames[val[2]], ")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
        m0 = gam(resp ~ s(cov1,sp=0.6) + s(cov2,sp=0.6), data=dat2)
        tmp = data.frame(model=paste0("gam(", modnames[val[1]], ", ", covnames[val[2]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
      }
    }
    colnames(tmpres)=c("model", yr)
    res=cbind(res,tmpres[,2,drop=FALSE])
  }
  return(res)
}
```

```{r table-appD-resinf2, echo=FALSE}
resinf2 <- function(resfun=c("aic","aicc","looRMSE","looMdAE","r2"), 
                    type=c("s1956","ns1956","s1984","ns1984")){
  type <- match.arg(type)
  load("FittedLooPred.Rdata")
  loomods <- switch(type,
         s1956 = FittedLooPred1956$LooPred,
         ns1956 = FittedLooPred.np1956$LooPred,
         s1984 = FittedLooPred1984$LooPred,
         ns1984 = FittedLooPred.np1984$LooPred
         )
  mods <- switch(type,
         s1956 = FittedLooPred1956$Fitted,
         ns1956 = FittedLooPred.np1956$Fitted,
         s1984 = FittedLooPred1984$Fitted,
         ns1984 = FittedLooPred.np1984$Fitted
         )
  loovals <- switch(resfun,
         aic = lapply(loomods, function(x){x$AIC}),
         aicc = lapply(loomods, function(x){x$AICc}),
         looRMSE = lapply(loomods, function(x){x$looRMSE}),
         looMdAE = lapply(loomods, function(x){x$looMdAE}),
         r2 = lapply(loomods, function(x){x$adj.r.sq})
         )
  vals <- switch(resfun,
         aic = lapply(mods, AIC),
         aicc = lapply(mods, AICc),
         looRMSE = lapply(mods, function(x){ret(x, "loo")}),
         looMdAE = lapply(mods,  function(x){ret(x, "looMd")}),
         r2 = lapply(mods,  function(x){ret(x, "r2")})
         )
  vals <- unlist(vals)
  yr1 <- min(mods[[1]]$data$Year)
  yr2 <- max(mods[[1]]$data$Year)
  
  res <- c()
  for(i in 1:length(loovals)){
     res <- rbind(res, loovals[[i]])
  }
  colnames(res) <- yr1:yr2
  res <- cbind(res, None=vals)
  res <- as.data.frame(res)
  res <- cbind(model=names(mods), res)

    
    
  
  dat$cov1=dat[[str_replace(resp,"0","1")]]
  m0 = gam(resp ~ offset(cov1), data=dat)
  tmp = data.frame(model="null offset w intercept",None=ret(m0, resfun))
  res = rbind(res, tmp)
  
  m0 = lm(resp ~ -1 + offset(cov1), data=dat)
  tmp = data.frame(model="null offset only",None=ret(m0, resfun))
  res = rbind(res, tmp)
  
  for(val in tests){
    if(length(val)==1){
      dat$cov1=dat[[covnames[val[1]]]]
      m0 = gam(resp ~ cov1, data=dat)
      tmp = data.frame(model=paste0("lin(", modnames[val[1]],")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
      m0 = gam(resp ~ s(cov1, sp=0.6), data=dat)
      tmp = data.frame(model=paste0("gam(", modnames[val[1]],")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
    }else{
      dat$cov1=dat[[covnames[val[1]]]]
      dat$cov2=dat[[covnames[val[2]]]]
      m0 = gam(resp ~ cov1 + cov2, data=dat)
      tmp = data.frame(model=paste0("lin(", modnames[val[1]], "), lin(", modnames[val[2]], ")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
      m0 = gam(resp ~ s(cov1,sp=0.6) + s(cov2,sp=0.6), data=dat)
      tmp = data.frame(model=paste0("gam(", modnames[val[1]], "), gam(", modnames[val[2]], ")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
    }
  }
  
  for(yr in min(dat$Year):max(dat$Year)){
    bad = yr
    dat2=dat
    dat2$resp[dat$Year%in%bad]=NA
    m0 = gam(resp ~ 1, data=dat2)
    #colname will be renamed below from None to year deleted
    tmpres = data.frame(model="null intercept",None=ret(m0, resfun))
    
    dat2$cov1=dat[[str_replace(resp,"0","1")]]
    m0 = gam(resp ~ offset(cov1), data=dat2)
    #colname will be renamed below from None to year deleted
    tmp = data.frame(model="null offset w intercept",None=ret(m0, resfun))
    tmpres = rbind(tmpres, tmp)
    
    m0 = lm(spawners0 ~ -1 + offset(cov1), data=dat2)
    #colname will be renamed below from None to year deleted
    tmp = data.frame(model="null offset only",None=ret(m0, resfun))
    tmpres = rbind(tmpres, tmp)
    
    for(val in tests){
      if(length(val)==1){
        dat2$cov1=dat[[covnames[val[1]]]]
        m0 = gam(resp ~ cov1, data=dat2)
        tmp = data.frame(model=paste0("lm(", modnames[val[1]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
        m0 = gam(resp ~ s(cov1, sp=0.6), data=dat2)
        tmp = data.frame(model=paste0("gam(", modnames[val[1]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
      }else{
        dat2$cov1=dat[[covnames[val[1]]]]
        dat2$cov2=dat[[covnames[val[2]]]]
        m0 = gam(resp ~ cov1 + cov2, data=dat2)
        tmp = data.frame(model=paste0("lm(", modnames[val[1]], ", ", covnames[val[2]], ")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
        m0 = gam(resp ~ s(cov1,sp=0.6) + s(cov2,sp=0.6), data=dat2)
        tmp = data.frame(model=paste0("gam(", modnames[val[1]], ", ", covnames[val[2]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
      }
    }
    colnames(tmpres)=c("model", yr)
    res=cbind(res,tmpres[,2,drop=FALSE])
  }
  return(res)
}
```

```{r table-appD-fits-loofits, echo=FALSE}
fits <- function(rmyr=1900, resp="spawners0", data=dat.nonspawners){

  covnames=c("nspawners1", "spawners1",
           "nspawners2", "spawners2")
modnames=c("Oct-Mar(t-1)", "Jul-Sep(t-1)",
           "Oct-Mar(t-2)", "Jul-Sep(t-2)")

tests=list(c(2),c(2,4),c(1),c(1,3),c(2,3), c(1,4))

retloodf <- function(mod, modname){
  loofit <- SardineForecast:::loogam(mod, LOO=TRUE)
  ret = list(model=modname, 
                           data=mod$data,
                           pred=loofit$pred,
                           AIC=loofit$AIC,
                           AICc=loofit$AICc,
                           adj.r.sq=loofit$adj.r.sq,
                           looRMSE=loofit$looRMSE,
                           looMdAE=loofit$looMdAE)
  return(ret)
}

resloo = list()

dat=data
dat[[resp]][dat$Year%in%rmyr]=NA
dat$resp = dat[[resp]]
m0 = gam(resp ~ 1, data=dat)
m0$data = dat[,c("Year","resp")]
res = list(`null intercept`=m0)
modname = "null intercept"
resloo[[modname]] = retloodf(m0, modname)
cat("\n", modname)

  dat$cov1=dat[[str_replace(resp,"0","1")]]
  m0 = gam(resp ~ offset(cov1), data=dat)
  m0$data = dat[,c("Year","resp","cov1")]
  modname = "null offset w intercept"
  res[[modname]] = m0
  resloo[[modname]] = retloodf(m0, modname)
  cat("\n", modname)
  
  m0 = lm(resp ~ -1 + offset(cov1), data=dat)
  m0$data = dat[,c("Year","resp","cov1")]
  modname = "null offset only"
  res[[modname]] = m0
  resloo[[modname]] = retloodf(m0, modname)
cat("\n", modname)
 
for(val in tests){
  if(length(val)==1){
  dat$cov1=dat[[covnames[val[1]]]]
  m0 = gam(resp ~ cov1, data=dat)
  m0$data = dat[,c("Year","resp", "cov1")]
  modname = paste0("lin(", modnames[val[1]],")")
  res[[modname]] = m0
  resloo[[modname]] = retloodf(m0, modname)
  cat("\n", modname)

  m0 = gam(resp ~ s(cov1, sp=0.6), data=dat)
  m0$data = dat[,c("Year","resp", "cov1")]
  modname = paste0("gam(", modnames[val[1]],")")
  res[[modname]] = m0
  resloo[[modname]] = retloodf(m0, modname)
  cat("\n", modname)

  }else{
    dat$cov1=dat[[covnames[val[1]]]]
    dat$cov2=dat[[covnames[val[2]]]]
    m0 = gam(resp ~ cov1 + cov2, data=dat)
    m0$data = dat[,c("Year","resp", "cov1", "cov2")]
    modname=paste0("lin(", modnames[val[1]], "), lin(", modnames[val[2]], ")")
    res[[modname]] = m0
    resloo[[modname]] = retloodf(m0, modname)
    cat("\n", modname)

    m0 = gam(resp ~ s(cov1,sp=0.6) + s(cov2,sp=0.6), data=dat)
    m0$data = dat[,c("Year","resp", "cov1", "cov2")]
    modname=paste0("gam(", modnames[val[1]], "), gam(", modnames[val[2]], ")")
    res[[modname]] = m0
    resloo[[modname]] = retloodf(m0, modname)
    cat("\n", modname)
  }
}

retloodfmarss <- function(modlist, inits.list, modname, dat){
pred <- pred.smooth <- aics <- aiccs <- loos <- loomds <- c()
for(t in 1:length(dat$resp)){
  tmp <- dat$resp; tmp[t]=NA
  fit <- MARSS(tmp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
  pred <- c(pred, fitted(fit, one.step.ahead = TRUE)[t])
  pred.smooth <- c(pred.smooth, fitted(fit)[t])
  aics <- c(aics, AIC(fit))
  aiccs <- c(aiccs, AICc(fit))
  loos <- c(loos, sqrt(mean(fitted(fit, one.step.ahead = TRUE)[1,]^2)))
  loomds <- c(loomds, median(abs(fitted(fit, one.step.ahead = TRUE)[1,])))
  cat(t, " ")
}
ret = list(model=modname, 
                         data=dat[,c("Year","resp")], 
                         pred=pred, pred.smooth=pred.smooth,
                         AIC=aics,
                         AICc=aiccs,
                         adj.r.sq=NULL,
                         looRMSE=loos,
                         looMdAE=loomds)
return(ret)
}


#dlm intercept
inits.list = list(x0=matrix(dat$resp[1]))
modlist <- list(U=matrix(0))
m0 <- MARSS(dat$resp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
m0$data = dat[,c("Year","resp")]
modname="dlm(intercept)"
res[[modname]] = m0
cat("\n", modname)
resloo[[modname]] = retloodfmarss(modlist, inits.list, modname, m0$data)

#dlm intercept + slope
Zt = array(1, dim=c(1,2,length(dat$resp)))
dat$cov1=1:length(dat$resp)
Zt[1,2,] = 1:length(dat$resp)
R=matrix("r")
Q=matrix(list(0),2,2); diag(Q)=c("q1","q2") 
inits.list = list(x0=matrix(c(dat$resp[1],0), nrow=2))
modlist = list(Z=Zt, Q=Q, U=matrix(0,1,2), B=diag(1,2), A=matrix(0), R=R)
m0 <- MARSS(dat$resp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
m0$data = dat[,c("Year","resp","cov1")]
modname="dlm(intercept, slope)"
res[[modname]] = m0
cat("\n", modname)
resloo[[modname]] = resloo[[modname]] = retloodfmarss(modlist, inits.list, modname, m0$data)

#dlm with time-varying multiplier on Oct-Mar t-1 catch
dat$cov1=dat[[covnames[1]]]
Zt = array(NA, dim=c(1,1,length(dat$cov1)))
Zt[1,1,] = dat$cov1
A=matrix("intercept")
R=matrix("r")
Q=matrix("q") 
inits.list = list(x0=matrix(c(0), nrow=1))
modlist = list(Z=Zt, Q=Q, U=matrix(0), B=diag(1), A=A, R=R)
m0 <- MARSS(dat$resp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
m0$data = dat[,c("Year","resp","cov1")]
modname = paste0("dlm(", modnames[1],")")
res[[modname]] = m0
cat("\n", modname)
resloo[[modname]] = resloo[[modname]] = retloodfmarss(modlist, inits.list, modname, m0$data)

#dlm with Jul-Sep t-1 catch
dat$cov1=dat[[covnames[2]]]
Zt = array(NA, dim=c(1,1,length(dat$cov1)))
Zt[1,1,] = dat$cov1
A=matrix("intercept")
R=matrix("r")
Q=matrix("q") #fix so doesn't go to zero
inits.list = list(x0=matrix(c(0), nrow=1))
modlist = list(Z=Zt, Q=Q, U=matrix(0), B=diag(1), A=A, R=R)
m0 <- MARSS(dat$resp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
m0$data = dat[,c("Year","resp", "cov1")]
modname = paste0("dlm(", modnames[2],")")
res[[modname]] = m0
cat("\n", modname)
resloo[[modname]] = resloo[[modname]] = retloodfmarss(modlist, inits.list, modname, m0$data)

return(list(Fitted=res, LooPred=resloo))
}
```

```{r appD-spawners-aic1956, echo=FALSE, fig.cap="Figure 1D. \\(\\Delta\\)AICc for the Jul-Sep landings base models with one year deleted using the full landings data set 1956-2015. Delta AIC is AIC of the model minus the AIC of the best (lowest AIC model) in the set. Black models were the best models in the set and within 0.5 AIC of each other. Green are models within 2 of the best model, thus competitive to the best models. Deleted year is shown on the x-axis; the last column, None, has no year removed.", fig.width=8, fig.height=figh, message=FALSE, warning=FALSE}
res <- resinf(resfun="aicc", data=dforig)
#res <- res[res$model%in%modelset,]
baseres=matrix(1,nrow(res),1)%*%matrix(as.numeric(res[1,2:ncol(res)]),nrow=1)
delaic=res[,2:ncol(res)]-baseres
rownames(delaic)=res$model

minrow <- apply(res[2:ncol(res)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(res),1)%*%matrix(as.numeric(res[cbind(minrow,2:ncol(res))]),nrow=1)
delaic2=res[,2:ncol(res)]-baseres
rownames(delaic2)=res$model

library(tidyverse)
df <- gather(cbind(model=res$model, delaic2), year, aic, 2:ncol(delaic2))
df$DelAICc <- cut(df$aic, c(-0.001, .5, 2, 4, 100))
levels(df$DelAICc) <- c("Best (0-0.5)", "Competitive (< 2)", "Uncompetitive (2-4)", "Poor (> 4)")

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelAICc), colour = "grey50")
p <- p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=Palette4)
p <- p + scale_x_discrete(breaks=c(seq(1960,max(dforig$Year),5),"None"))
p + xlab('year removed')
```

```{r appD-spawners-aic1984, echo=FALSE, fig.cap="Figure 2D. Delta AICc for the Jul-Sep landings base models with one year deleted using only the landings data that overlap with the environmental data 1984-2015. See Figure 1D for an explantion of the figure.", fig.width=8, fig.height=figh, message=FALSE, warning=FALSE}
res <- resinf(resfun="aicc", data=dat.nonspawners)
#res <- res[res$model%in%modelset,]
baseres=matrix(1,nrow(res),1)%*%matrix(as.numeric(res[1,2:ncol(res)]),nrow=1)
delaic=res[,2:ncol(res)]-baseres
rownames(delaic)=res$model

minrow <- apply(res[2:ncol(res)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(res),1)%*%matrix(as.numeric(res[cbind(minrow,2:ncol(res))]),nrow=1)
delaic2=res[,2:ncol(res)]-baseres
rownames(delaic2)=res$model

library(tidyverse)
df <- gather(cbind(model=res$model, delaic2), year, aic, 2:ncol(delaic2))
df$DelAICc <- cut(df$aic, c(-0.001, .5, 2, 4, 100))
levels(df$DelAICc) <- c("Best (0-0.5)", "Competitive (< 2)", "Uncompetitive (2-4)", "Poor (> 4)")

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelAICc), colour = "grey50")
p <- p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=Palette4)
p <- p + scale_x_discrete(breaks=c(seq(1960,max(dforig$Year),5),"None"))
p + xlab('year removed')
```


```{r appD-spawners-fits2, echo=FALSE, fig.cap="Figure 1D. Leave one out (LOO) one step ahead prediction errors for the linear, GAM, and DLM models of Jul-Sep landings. In panels A-C, the data point at year t on the x-axis is predicted from the data up to year t-1, and the model is fit to all data except year t. In panel D, the predictions use all the data; the model is still fit without year t. The predictions in panel D are called the smoothed predictions. The dashed line in the DLM plots is the best overall model in terms of root mean squared error.", fig.width=8, fig.height=figh, message=FALSE, warning=FALSE}
# FittedLooPred <- fits(data=dforig)
# FittedLooPred.np <- fits(data=dforig, resp="nspawners0")
# save(FittedLooPred, file="FittedLooPred.Rdata")
load("FittedLooPred.Rdata")

myfits <- FittedLooPred$LooPred
linmods = stringr::str_detect(names(myfits),"lin")
fit <- myfits[[1]]
p <- ggplot() + geom_point(data=fit$data, aes(x=Year, y=resp, color="Actual"))
for(fit in myfits[linmods]){
  tmp <- data.frame(Year=na.omit(fit$data)$Year, pred=fit$pred)
  p <- p + geom_line(data=tmp, aes(x=Year, y=pred, color="Predicted"))
}
p1 <- p + scale_color_manual( values = c( Actual="black", Predicted="blue")) +  labs(color="One-step-ahead") + xlab('') +  ylab('Jul-Sep Catch') + theme_classic() + theme(
  legend.justification = c(1,0), legend.position = c(1,0),
  legend.key = element_rect(colour = "transparent", fill = "white"))
grob <- grobTree(textGrob("linear models", x=0.1,  y=0.95, hjust=0, gp=gpar(col="blue", fontsize=13)))
p1 <- p1 + annotation_custom(grob)
grob <- grobTree(textGrob("A", x=0.05,  y=0.1, hjust=0, gp=gpar(col="black", fontsize=13)))
p1 <- p1 + annotation_custom(grob)

gammods = stringr::str_detect(names(myfits),"gam")
fit <- myfits[[1]]
p <- ggplot() + geom_point(data=fit$data, aes(x=Year, y=resp, color="Actual"))
for(fit in myfits[gammods]){
  tmp <- data.frame(Year=na.omit(fit$data)$Year, pred=fit$pred)
  p <- p + geom_line(data=tmp, aes(x=Year, y=pred, color="Predicted"))
}
p2 <- p + scale_color_manual( values = c( Actual="black", Predicted="blue")) +  labs(color="One-step-ahead") + xlab('') +  ylab('Jul-Sep Catch') + theme_classic() + theme(
  legend.justification = c(1,0), legend.position = c(1,0),
  legend.key = element_rect(colour = "transparent", fill = "white"))
grob <- grobTree(textGrob("GAM models", x=0.1,  y=0.95, hjust=0, gp=gpar(col="blue", fontsize=13)))
p2 <- p2 + annotation_custom(grob)
grob <- grobTree(textGrob("B", x=0.05,  y=0.1, hjust=0, gp=gpar(col="black", fontsize=13)))
p2 <- p2 + annotation_custom(grob)

fit <- myfits[[1]]
p <- ggplot() + geom_point(data=fit$data, aes(x=Year, y=resp, color="Actual"))
dlmmods = stringr::str_detect(names(myfits),"dlm")
for(fit in myfits[dlmmods]){
  tmp <- data.frame(Year=fit$data$Year, pred=fit$pred)
  ltyp <- "solid"
  if(fit$model=="dlm(Oct-Mar(t-1))") ltyp <- "twodash"
  p <- p + geom_line(data=tmp, aes(x=Year, y=pred, color="Predicted"), linetype=ltyp)
}
p3 <- p + scale_color_manual( values = c( Actual="black", Predicted="blue")) +  labs(color="One-step ahead") + xlab('') +  ylab('Jul-Sep Catch') + theme_classic() + theme(
  legend.justification = c(1,0), legend.position = c(1,0),
  legend.key = element_rect(colour = "transparent", fill = "white"))
grob <- grobTree(textGrob("DLM models", x=0.1,  y=0.95, hjust=0, gp=gpar(col="blue", fontsize=13)))
p3 <- p3 + annotation_custom(grob)
grob <- grobTree(textGrob("C", x=0.05,  y=0.1, hjust=0, gp=gpar(col="black", fontsize=13)))
p3 <- p3 + annotation_custom(grob)

fit <- myfits[[1]]
p <- ggplot() + geom_point(data=fit$data, aes(x=Year, y=resp, color="Actual"))
dlmmods = stringr::str_detect(names(myfits),"dlm")
for(fit in myfits[dlmmods]){
  tmp <- data.frame(Year=fit$data$Year, pred=fit$pred.smooth)
  ltyp <- "solid"
  if(fit$model=="dlm(Oct-Mar(t-1))") ltyp <- "twodash"
  p <- p + geom_line(data=tmp, aes(x=Year, y=pred, color="Predicted"), linetype=ltyp)
}
p4 <- p + scale_color_manual( values = c( Actual="black", Predicted="blue")) +  labs(color="Smoothed") + xlab('') +  ylab('Jul-Sep Catch') + theme_classic() + theme(
  legend.justification = c(1,0), legend.position = c(1,0),
  legend.key = element_rect(colour = "transparent", fill = "white"))
grob <- grobTree(textGrob("DLM models", x=0.1,  y=0.95, hjust=0, gp=gpar(col="blue", fontsize=13)))
p4 <- p4 + annotation_custom(grob)
grob <- grobTree(textGrob("D", x=0.05,  y=0.1, hjust=0, gp=gpar(col="black", fontsize=13)))
p4 <- p4 + annotation_custom(grob)

gridExtra::grid.arrange(p1, p3, p2, p4, nrow = 2)
```



```{r appd-spawners-loo, echo=FALSE, fig.cap="Figure 2D. Leave-one-out predictive performance (leave out a year, fit, predict that year) for the Jul-Sep landings base models. The performance (DelLOO) is the RSME (root mean square error) from LOO from all models was compared to the LOO RSME for a base model: GAM(Oct-Mar(t-1)). Thus results are relative to the GAM(Oct-Mar(t-1)) model. Black is better predictive performance relative to this model, green is similar, and yellow and orange are worse.", fig.width=8, fig.height=figh, message=FALSE, warning=FALSE, eval=FALSE}

# res2 <- resinf(resfun="loo", resp="spawner0")
# res <- resinf(resfun="loo", resp="nspawner0")
# save(res, res2, file="basemodsloo.RData")
load("basemodsloo.RData")
vals=res2.all
vals <- vals[vals$model%in%modelset,]
minrow <- apply(vals[,2:ncol(vals)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(vals),1)%*%matrix(as.numeric(vals[cbind(minrow,2:ncol(vals))]),nrow=1)
tmp=vals[,2:ncol(vals)]/baseres
rownames(tmp)=vals$model

library(tidyverse)
df <- gather(cbind(model=vals$model, tmp), year, lev, 2:ncol(tmp))
df$DelLOO <- cut(df$lev, c(-.2,-.01,0.01,.05,1))
df$DelLOO <- cut(df$lev, c(.999,1.01,1.05,1.10,1.2,3))
levels(df$DelLOO) <- c("Best (< 1%)", "Similar (1-2%)", "Worse (5-10%)", "Much worse (10-20%)", "Worst (>20%)")

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelLOO), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=c(Palette4,"red"))
```


```{r appd-spawners2-aic-9495, echo=FALSE,fig.cap="Figure 3D. Delta AIC for the Jul-Sep landings base models with 1995 and one other year deleted. The deleted year is shown on the x-axis.", fig.width=8, fig.height=figh, message=FALSE, warning=FALSE, eval=FALSE}
res <- spawnerinf(rmyr, resfun="aicc")
res <- res[res$model%in%modelset,]

minrow <- apply(res[2:ncol(res)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(res),1)%*%matrix(as.numeric(res[cbind(minrow,2:ncol(res))]),nrow=1)
delaic2=res[,2:ncol(res)]-baseres
delaic2=delaic2[,!(colnames(delaic2)%in%rmyr)]
rownames(delaic2)=res$model

library(tidyverse)
df <- gather(cbind(model=res$model, delaic2), year, aic, 2:ncol(delaic2))
df$DelAIC <- cut(df$aic, c(-0.001, .5, 2, 4, 100))
levels(df$DelAIC) <- c("Best (0-0.5)", "Competitive (< 2)", "Uncompetitive (2-4)", "Poor (> 4)")

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelAIC), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=Palette4)
```

```{r appd-spawners-loo-9495, echo=FALSE,fig.cap="Figure 4D. Leave-one-out predictive performance for the Jul-Sep landings base models with 1995 removed. See Figure 2D for details on the figure.", fig.width=8, fig.height=figh, message=FALSE, warning=FALSE, eval=FALSE}
# res2 <- resinf(resfun="loo", resp="spawner0")
# res <- resinf(resfun="loo", resp="nspawner0")
# save(res, res2, file="basemodsloo.RData")
load("basemodsloo.RData")
vals=res2.8694
vals <- vals[vals$model%in%modelset,]
minrow <- apply(vals[,2:ncol(vals)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(vals),1)%*%matrix(as.numeric(vals[cbind(minrow,2:ncol(vals))]),nrow=1)
tmp=vals[,2:ncol(vals)]/baseres
rownames(tmp)=vals$model

library(tidyverse)
df <- gather(cbind(model=vals$model, tmp), year, lev, 2:ncol(tmp))
df$DelLOO <- cut(df$lev, c(-.2,-.01,0.01,.05,1))
df$DelLOO <- cut(df$lev, c(.999,1.01,1.05,1.10,1.2,3))
levels(df$DelLOO) <- c("Best (< 1%)", "Similar (1-2%)", "Worse (5-10%)", "Much worse (10-20%)", "Worst (>20%)")
p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelLOO), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=c(Palette4,"red"))
```

```{r appd-spawners-r2, echo=FALSE,fig.cap=paste0("Figure 5D. R-squared for the Jul-Sep landings base models with one year deleted. The deleted year is shown on the x-axis."), fig.width=8,fig.height=figh,message=FALSE,warning=FALSE, eval=FALSE}
res <- spawnerinf(rmyr, resfun="r2")
res <- res[res$model%in%modelset,]

library(tidyverse)
df <- gather(res, year, lev, 2:ncol(res))
df$r2 <- cut(df$lev, c(0, .3, .5, .6, .7))

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = r2), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=Palette4)
```

```{r, results="asis", echo=FALSE}
cat("\\clearpage")
```

## Validation of the Oct-Mar landings base models

The Figure 6D shows that for Oct-Mar landings the best model was always GAM with Oct-Mar in the prior season and Jul-Sep landings two seasons prior.  


Again `r paste(rmyr, collapse=" and ")` `r ifelse(length(rmyr)==1,"was","were")` deleted and the leave-one-out analysis was repeated. The Figure 4D shows the best model is still always GAM with Oct-Mar in the prior season and Jul-Sep landings two seasons prior.

```{r appD-nspawners-fits2, echo=FALSE, fig.cap="Figure 3D. Leave one out (LOO) one step ahead prediction errors for the linear, GAM, and DLM models of Oct-Mar landings. In panels A-C, the data point at year t on the x-axis is predicted from the data up to year t-1, and the model is fit to all data except year t. In panel D, the predictions use all the data; the model is still fit without year t. The predictions in panel D are called the smoothed predictions. The dashed line in the DLM plots is the best overall model in terms of root mean squared error.", fig.width=8, fig.height=figh, message=FALSE, warning=FALSE}
library(grid)
dforig=data.frame(Year=respdat$Year, 
              spawners0=respdat$spawners0, spawners1=respdat$spawners1, spawners2=respdat$spawners2, 
              nspawners0=respdat$nspawners0, nspawners1=respdat$nspawners1, 
               nspawners2=respdat$nspawners2)
dforig <- na.omit(dforig)
# FittedLooPred <- fits(data=dforig)
# save(FittedLooPred, file="FittedLooPred.Rdata")
load("FittedLooPred.Rdata")

myfits <- FittedLooPred.np$LooPred
linmods = stringr::str_detect(names(myfits),"lin")
fit <- myfits[[1]]
p <- ggplot() + geom_point(data=fit$data, aes(x=Year, y=resp, color="Actual")) +
  ylim(6,13)
for(fit in myfits[linmods]){
  tmp <- data.frame(Year=na.omit(fit$data)$Year, pred=fit$pred)
  p <- p + geom_line(data=tmp, aes(x=Year, y=pred, color="Predicted"))
}
p1 <- p + scale_color_manual( values = c( Actual="black", Predicted="blue")) +  labs(color="1-step-ahead") + xlab('') +  ylab('Oct-Mar Catch') + theme_classic() + theme(
  legend.justification = c(1,0), legend.position = c(1,0),
  legend.key = element_rect(colour = "transparent", fill = "white"))
grob <- grobTree(textGrob("linear models", x=0.1,  y=0.95, hjust=0, gp=gpar(col="blue", fontsize=13)))
p1 <- p1 + annotation_custom(grob)
grob <- grobTree(textGrob("A", x=0.05,  y=0.1, hjust=0, gp=gpar(col="black", fontsize=13)))
p1 <- p1 + annotation_custom(grob)

gammods = stringr::str_detect(names(myfits),"gam")
fit <- myfits[[1]]
p <- ggplot() + geom_point(data=fit$data, aes(x=Year, y=resp, color="Actual")) +
  ylim(6,13)
for(fit in myfits[gammods]){
  tmp <- data.frame(Year=na.omit(fit$data)$Year, pred=fit$pred)
  p <- p + geom_line(data=tmp, aes(x=Year, y=pred, color="Predicted"))
}
p2 <- p + scale_color_manual( values = c( Actual="black", Predicted="blue")) +  labs(color="1-step-ahead") + xlab('') +  ylab('Oct-Mar Catch') + theme_classic() + theme(
  legend.justification = c(1,0), legend.position = c(1,0),
  legend.key = element_rect(colour = "transparent", fill = "white"))
grob <- grobTree(textGrob("GAM models", x=0.1,  y=0.95, hjust=0, gp=gpar(col="blue", fontsize=13)))
p2 <- p2 + annotation_custom(grob)
grob <- grobTree(textGrob("B", x=0.05,  y=0.1, hjust=0, gp=gpar(col="black", fontsize=13)))
p2 <- p2 + annotation_custom(grob)

fit <- myfits[[1]]
p <- ggplot() + geom_point(data=fit$data, aes(x=Year, y=resp, color="Actual")) +
  ylim(6,13)
dlmmods = stringr::str_detect(names(myfits),"dlm")
for(fit in myfits[dlmmods]){
  tmp <- data.frame(Year=fit$data$Year, pred=fit$pred)
  ltyp <- "solid"
  if(fit$model=="dlm(Oct-Mar(t-1))") ltyp <- "twodash"
  p <- p + geom_line(data=tmp, aes(x=Year, y=pred, color="Predicted"), linetype=ltyp)
}
p3 <- p + scale_color_manual( values = c( Actual="black", Predicted="blue")) +  labs(color="1-step ahead") + xlab('') +  ylab('Oct-Mar Catch') + theme_classic() + theme(
  legend.justification = c(1,0), legend.position = c(1,0),
  legend.key = element_rect(colour = "transparent", fill = "white"))
grob <- grobTree(textGrob("DLM models", x=0.1,  y=0.95, hjust=0, gp=gpar(col="blue", fontsize=13)))
p3 <- p3 + annotation_custom(grob)
grob <- grobTree(textGrob("C", x=0.05,  y=0.1, hjust=0, gp=gpar(col="black", fontsize=13)))
p3 <- p3 + annotation_custom(grob)

fit <- myfits[[1]]
p <- ggplot() + geom_point(data=fit$data, aes(x=Year, y=resp, color="Actual")) +
  ylim(6,13)
dlmmods = stringr::str_detect(names(myfits),"dlm")
for(fit in myfits[dlmmods]){
  tmp <- data.frame(Year=fit$data$Year, pred=fit$pred.smooth)
  ltyp <- "solid"
  if(fit$model=="dlm(Oct-Mar(t-1))") ltyp <- "twodash"
  p <- p + geom_line(data=tmp, aes(x=Year, y=pred, color="Predicted"), linetype=ltyp)
}
p4 <- p + scale_color_manual( values = c( Actual="black", Predicted="blue")) +  labs(color="Smoothed") + xlab('') +  ylab('Oct-Mar Catch') + theme_classic() + theme(
  legend.justification = c(1,0), legend.position = c(1,0),
  legend.key = element_rect(colour = "transparent", fill = "white"))
grob <- grobTree(textGrob("DLM models", x=0.1,  y=0.95, hjust=0, gp=gpar(col="blue", fontsize=13)))
p4 <- p4 + annotation_custom(grob)
grob <- grobTree(textGrob("D", x=0.05,  y=0.1, hjust=0, gp=gpar(col="black", fontsize=13)))
p4 <- p4 + annotation_custom(grob)

gridExtra::grid.arrange(p1, p3, p2, p4, nrow = 2)
```

```{r appD-nspawners-aic, echo=FALSE,fig.cap="Figure 4D. Delta AIC for the Oct-Mar landings base models with one year deleted. The deleted year is shown on the x-axis.", fig.width=8,fig.height=figh,message=FALSE,warning=FALSE}
res <- resinf(resfun="aicc", resp="nspawners0", data=dforig)
res <- res[res$model%in%modelset,]
baseres=matrix(1,nrow(res),1)%*%matrix(as.numeric(res[1,2:ncol(res)]),nrow=1)
delaic=res[,2:ncol(res)]-baseres
rownames(delaic)=res$model

minrow <- apply(res[,2:ncol(res)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(res),1)%*%matrix(as.numeric(res[cbind(minrow,2:ncol(res))]),nrow=1)
delaic2=res[,2:ncol(res)]-baseres
rownames(delaic2)=res$model

library(tidyverse)
df <- gather(cbind(model=res$model, delaic2), year, aic, 2:ncol(delaic2))
df$DelAICc <- cut(df$aic, c(-0.001, .5, 2, 4, 100))
levels(df$DelAICc) <- c("Best (0-0.5)", "Competitive (< 2)", "Uncompetitive (2-4)", "Poor (> 4)")

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelAICc), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=Palette4)
```



```{r appd-nspawners-aic2, echo=FALSE,fig.cap=paste0("Figure 8D. Delta AIC for the Oct-Mar landings base models with ", paste(rmyr, collapse=" and "), " and one additional year deleted. Deleted year is shown on the x-axis."), fig.width=8,fig.height=figh,message=FALSE,warning=FALSE, eval=FALSE}
rmyr <- 1994:1995
res <- resinf(rmyr, resfun="aicc", resp="nspawner0")
res <- res[res$model%in%modelset,]

minrow <- apply(res[,2:ncol(res)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(res),1)%*%matrix(as.numeric(res[cbind(minrow,2:ncol(res))]),nrow=1)
delaic2=res[,2:ncol(res)]-baseres
rownames(delaic2)=res$model
delaic2=delaic2[,!(colnames(delaic2)%in%rmyr)]

library(tidyverse)
df <- gather(cbind(model=res$model, delaic2), year, aic, 2:ncol(delaic2))
df$DelAIC <- cut(df$aic, c(-0.001, .5, 2, 4, 30))
levels(df$DelAIC) <- c("Best (0-0.5)", "Competitive (< 2)", "Uncompetitive (2-4)", "Poor (> 4)")

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelAIC), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=Palette4)
```

```{r appd-nspawners-loo-9495, echo=FALSE,fig.cap=paste0("Figure 9D. Leave-one-out predictive performance for the Oct-Sep landings base models with ", paste(rmyr, collapse=" and "), " and one additional year deleted. See Figure 7D for details on the figure."), fig.width=8, fig.height=figh, message=FALSE, warning=FALSE,eval=FALSE}
# res2 <- resinf(resfun="loo", resp="spawner0")
# res <- resinf(resfun="loo", resp="nspawner0")
# save(res, res2, file="basemodsloo.RData")
load("basemodsloo.RData")
vals=res.86879495
vals <- vals[vals$model%in%modelset,]
baseres=matrix(1,nrow(vals),1)%*%matrix(as.numeric(vals[cbind(6,2:ncol(vals))]),nrow=1)
minrow <- apply(vals[,2:ncol(vals)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(vals),1)%*%matrix(as.numeric(vals[cbind(minrow,2:ncol(vals))]),nrow=1)
tmp=vals[,2:ncol(vals)]/baseres
rownames(tmp)=vals$model
tmp=tmp[,!(colnames(tmp)%in%rmyr)]


library(tidyverse)
tmp <- cbind(model=vals$model, tmp)
df <- gather(tmp, year, lev, 2:ncol(tmp))
#df$DelLOO <- cut(df$lev, c(-.01,0.01,.02,.5, 1))
df$DelLOO <- cut(df$lev, c(.999,1.01,1.05,1.10,1.2,3))
levels(df$DelLOO) <- c("Best (< 1%)", "Similar (1-2%)", "Worse (5-10%)", "Much worse (10-20%)", "Worst (>20%)")
p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelLOO), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=c(Palette4,"red"))
```


```{r appd-nspawners-r2, echo=FALSE,fig.cap=paste0("Figure 10D. R-squared for the Oct-Mar landings base models. Deleted year is shown on the x-axis."), fig.width=8,fig.height=figh,message=FALSE,warning=FALSE, eval=FALSE}
res <- resinf(resfun="r2", resp="nspawners0")
res <- res[res$model%in%modelset,]
#res=res[,!(colnames(res)%in%rmyr)]

library(tidyverse)
df <- gather(res, year, lev, 2:ncol(res))
df$r2 <- cut(df$lev, c(0, .3, .5, .6, .7))

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = r2), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=Palette4)
```

```{r appd-nspawners-loo, echo=FALSE,fig.cap="Figure 7D. Leave-one-out predictive performance for the Oct-Mar landings base models.", fig.width=8,fig.height=figh,message=FALSE,warning=FALSE,eval=FALSE}
# res2 <- resinf(resfun="loo", resp="spawner0")
# res <- resinf(resfun="loo", resp="nspawner0")
# save(res, res2, file="basemodsloo.RData")
load("basemodsloo1956-2015.RData")
vals=res.all
vals <- vals[vals$model%in%modelset,]
#baseres=matrix(1,nrow(vals),1)%*%matrix(as.numeric(vals[cbind(12,2:ncol(vals))]),nrow=1)
minrow <- apply(vals[,2:ncol(vals)],2,function(x){which(x==min(x))})
baseres=matrix(1,nrow(vals),1)%*%matrix(as.numeric(vals[cbind(minrow,2:ncol(vals))]),nrow=1)
tmp=vals[,2:ncol(vals)]/baseres
rownames(tmp)=vals$model

library(tidyverse)
df <- gather(cbind(model=vals$model, tmp), year, lev, 2:ncol(tmp))
df$DelLOO <- cut(df$lev, c(-.01,0.01,.02,.5, 1))
df$DelLOO <- cut(df$lev, c(.999,1.01,1.05,1.10,1.2,3))
levels(df$DelLOO) <- c("Best (< 1%)", "Similar (1-2%)", "Worse (5-10%)", "Much worse (10-20%)", "Worst (>20%)")

p <- ggplot(df, aes(year, model)) +
  geom_tile(aes(fill = DelLOO), colour = "grey50")
p + theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1), aspect.ratio = aspr) + scale_fill_manual(values=c(Palette4,"red"))
```



```{r, results="asis", echo=FALSE}
cat("\\clearpage")
```
