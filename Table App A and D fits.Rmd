---
title: 'Run models: only past catch'
output:
  pdf_document: default
  html_document:
    df_print: paged
  word_document: default
header-includes: \usepackage[labelformat=empty]{caption}
---

This file runs the model and saves in `FittedLooPred.RData`. This is used in Appendix A and Appendix G tables.


```{r AD-packages, echo=FALSE}
library(mgcv)
library(SardineForecast)
library(MARSS)
```

```{r AD-funs}
ret <- function(mod, resfun){
    if(resfun=="aic") return(AIC(mod))
    if(resfun=="aicc") return(SardineForecast:::AICc(mod))
    if(resfun=="loo") return(SardineForecast:::loogam(mod)$RMSE)
    if(resfun=="looMd") return(SardineForecast:::loogam(mod)$MdAE)
    if(resfun=="r2"){
      if(class(mod)[1]=="gam") return(summary(mod)$r.sq)
      if(class(mod)[1]=="lm") return(summary(mod)$adj.r.squared)
    } 
  }

dforig=data.frame(Year=respdat$Year, 
              spawners0=respdat$spawners0, spawners1=respdat$spawners1, spawners2=respdat$spawners2, 
              nspawners0=respdat$nspawners0, nspawners1=respdat$nspawners1, 
               nspawners2=respdat$nspawners2)
dforig <- na.omit(dforig)

```

## Models

The base catch model is the model with no environmental covariates only prior landings as covariates.  

Three types of base models were fit. The first two were GAM and linear models with Jul-Sep and Oct-Mar in the prior season only or prior season and two seasons prior as covariates. $c$ is the response variable: landings during the two seasons, either Jul-Sep or Oct-Mar.

\begin{align*}
\text{GAM t-1}: X_t = \alpha + s(c_{t-1}) + e_t \\
\text{Linear t-1}: X_t = \alpha + \beta c_{t-1} + e_t \\
\text{GAM t-1, t-2}: X_t = \alpha + s(c_{t-1}) + s(d_{t-2}) + e_t \\
\text{Linear t-1, t-2}: X_t = \alpha + \beta c_{t-1} + d_{t-2} + e_t
\end{align*}
where $c_{t-1}$ was either $S_{t-1}$ (Jul-Sep landings in prior season) or $N_{t-1}$ (Oct-Mar landings in prior season) and $d_{t-2}$ was the same but 2 seasons prior.

These types of models do not allow the model parameters (the intercept $\alpha$ and effect parameter $\beta$) to vary in time.  The second type of models were dynamic linear models (DLMs). DLMs allow the parameters to evolve in time. Two types of DLMs were used, an intercept only model where the intercept $\alpha$ evolves and a linear model where the effect parameter $\beta$ is allowed to evolve:
\begin{align*}
\text{DLM intercept only}: X_t = \alpha_t + e_t \\
\text{DLM intercept and slope}: X_t = \alpha_t + \beta_t t + e_t \\
\text{DLM intercept and effect}: X_t = \alpha_t + \beta_t c_{t-1} + e_t
\end{align*}

In addition to the GAM, linear and DLM models, three null models were included in the tested model sets: 
\begin{align*}
\text{intercept only}: X_t = \alpha + e_t \\
\text{intercept and prior catch}: X_t = \alpha_t + X_{t-1} + e_t \\
\text{prior catch only}: X_t = X_{t-1} + e_t
\end{align*}
The 'intercept only' is a flat level model. The 'prior catch only' simply uses the prior value of the time series (in this case landings) as the prediction and is a standard null model for prediction. The 'intercept and prior catch' combines these two null models.

The models were fit to the 1956-2015 landings (full data) and 1984-2015 (data that overlap the environmental covariates). 

The model performance was measured by AIC, AICc and LOO prediction. The LOO prediction error is the data point $t$ minus the predited value for data point $t$. This is repeated for all data points $t$. The influence of single data points to on model performance was evaluated by leaving out one data point, fitting to the remaining data and computing the model performance (via AIC, AICc or LOO prediction error). 


```{r resinf-function}
resinf <- function(rmyr=1900, resfun="aic", data=dat.nonspawners, resp="spawners0"){
  
  covnames=c("nspawners1", "spawners1",
             "nspawners2", "spawners2")
  modnames=c("Oct-Mar(t-1)", "Jul-Sep(t-1)",
             "Oct-Mar(t-2)", "Jul-Sep(t-2)")
  
  tests=list(c(2),c(2,4),c(1),c(1,3),c(2,3), c(1,4))
  ## SPAWNERS
  dat=data
  dat[[resp]][dat$Year%in%rmyr]=NA
  dat$resp = dat[[resp]]
  m0 = gam(resp ~ 1, data=dat)
  res = data.frame(model="null intercept", None=ret(m0, resfun))
  
  dat$cov1=dat[[str_replace(resp,"0","1")]]
  m0 = gam(resp ~ offset(cov1), data=dat)
  tmp = data.frame(model="null offset w intercept",None=ret(m0, resfun))
  res = rbind(res, tmp)
  
  m0 = lm(resp ~ -1 + offset(cov1), data=dat)
  tmp = data.frame(model="null offset only",None=ret(m0, resfun))
  res = rbind(res, tmp)
  
  for(val in tests){
    if(length(val)==1){
      dat$cov1=dat[[covnames[val[1]]]]
      m0 = gam(resp ~ cov1, data=dat)
      tmp = data.frame(model=paste0("lin(", modnames[val[1]],")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
      m0 = gam(resp ~ s(cov1, sp=0.6), data=dat)
      tmp = data.frame(model=paste0("gam(", modnames[val[1]],")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
    }else{
      dat$cov1=dat[[covnames[val[1]]]]
      dat$cov2=dat[[covnames[val[2]]]]
      m0 = gam(resp ~ cov1 + cov2, data=dat)
      tmp = data.frame(model=paste0("lin(", modnames[val[1]], "), lin(", modnames[val[2]], ")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
      m0 = gam(resp ~ s(cov1,sp=0.6) + s(cov2,sp=0.6), data=dat)
      tmp = data.frame(model=paste0("gam(", modnames[val[1]], "), gam(", modnames[val[2]], ")"), None=ret(m0, resfun))
      res = rbind(res, tmp)
    }
  }
  
  for(yr in min(dat$Year):max(dat$Year)){
    bad = yr
    dat2=dat
    dat2$resp[dat$Year%in%bad]=NA
    m0 = gam(resp ~ 1, data=dat2)
    #colname will be renamed below from None to year deleted
    tmpres = data.frame(model="null intercept",None=ret(m0, resfun))
    
    dat2$cov1=dat[[str_replace(resp,"0","1")]]
    m0 = gam(resp ~ offset(cov1), data=dat2)
    #colname will be renamed below from None to year deleted
    tmp = data.frame(model="null offset w intercept",None=ret(m0, resfun))
    tmpres = rbind(tmpres, tmp)
    
    m0 = lm(spawners0 ~ -1 + offset(cov1), data=dat2)
    #colname will be renamed below from None to year deleted
    tmp = data.frame(model="null offset only",None=ret(m0, resfun))
    tmpres = rbind(tmpres, tmp)
    
    for(val in tests){
      if(length(val)==1){
        dat2$cov1=dat[[covnames[val[1]]]]
        m0 = gam(resp ~ cov1, data=dat2)
        tmp = data.frame(model=paste0("lm(", modnames[val[1]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
        m0 = gam(resp ~ s(cov1, sp=0.6), data=dat2)
        tmp = data.frame(model=paste0("gam(", modnames[val[1]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
      }else{
        dat2$cov1=dat[[covnames[val[1]]]]
        dat2$cov2=dat[[covnames[val[2]]]]
        m0 = gam(resp ~ cov1 + cov2, data=dat2)
        tmp = data.frame(model=paste0("lm(", modnames[val[1]], ", ", covnames[val[2]], ")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
        m0 = gam(resp ~ s(cov1,sp=0.6) + s(cov2,sp=0.6), data=dat2)
        tmp = data.frame(model=paste0("gam(", modnames[val[1]], ", ", covnames[val[2]],")"), None=ret(m0, resfun))
        tmpres = rbind(tmpres, tmp)
      }
    }
    colnames(tmpres)=c("model", yr)
    res=cbind(res,tmpres[,2,drop=FALSE])
  }
  return(res)
}
```

```{r table-appD-resinf2, echo=FALSE}
resinf2 <- function(resfun=c("aic","aicc","looRMSE","looMdAE","r2"), 
                    type=c("s1956","ns1956","s1984","ns1984")){
  require(SardineForecast)
  type <- match.arg(type)
  load("FittedLooPred.Rdata")
  loomods <- switch(type,
         s1956 = FittedLooPred1956$LooPred,
         ns1956 = FittedLooPred.np1956$LooPred,
         s1984 = FittedLooPred1984$LooPred,
         ns1984 = FittedLooPred.np1984$LooPred
         )
  mods <- switch(type,
         s1956 = FittedLooPred1956$Fitted,
         ns1956 = FittedLooPred.np1956$Fitted,
         s1984 = FittedLooPred1984$Fitted,
         ns1984 = FittedLooPred.np1984$Fitted
         )
  loovals <- switch(resfun,
         aic = lapply(loomods, function(x){x$AIC}),
         aicc = lapply(loomods, function(x){x$AICc}),
         looRMSE = lapply(loomods, function(x){x$looRMSE}),
         looMdAE = lapply(loomods, function(x){x$looMdAE}),
         r2 = lapply(loomods, function(x){x$adj.r.sq})
         )
  vals <- switch(resfun,
         aic = lapply(mods, AIC),
         aicc = lapply(mods, SardineForecast::AICc),
         looRMSE = lapply(mods, 
                          function(x){
                            m <- try(ret(x, "loo"), silent=TRUE);
                            if(inherits(m,"try-error")){return(NA)}else{return(m)}
                            }),
         looMdAE = lapply(mods,  function(x){
                            m <- try(ret(x, "looMd"), silent=TRUE);
                            if(inherits(m,"try-error")){return(NA)}else{return(m)}
                            }),
         r2 = lapply(mods,  function(x){ret(x, "r2")})
         )
  vals <- unlist(vals)
  yr1 <- min(mods[[1]]$data$Year)
  yr2 <- max(mods[[1]]$data$Year)
  
  res <- c()
  for(i in 1:length(loovals)){
     res <- rbind(res, loovals[[i]])
  }
  colnames(res) <- yr1:yr2
  res <- cbind(res, None=vals)
  res <- as.data.frame(res)
  res <- cbind(model=names(mods), res)

  return(res)
}
```

```{r fits-function, echo=FALSE}
fits <- function(rmyr=1900, resp="spawners0", data=dat.nonspawners){

  covnames=c("nspawners1", "spawners1",
           "nspawners2", "spawners2")
modnames=c("Oct-Mar(t-1)", "Jul-Sep(t-1)",
           "Oct-Mar(t-2)", "Jul-Sep(t-2)")

tests=list(c(2),c(2,4),c(1),c(1,3),c(2,3), c(1,4))

retloodf <- function(mod, modname){
  loofit <- SardineForecast:::loogam(mod, LOO=TRUE)
  ret = list(model=modname, 
                           data=mod$data,
                           pred=loofit$pred,
                           AIC=loofit$AIC,
                           AICc=loofit$AICc,
                           adj.r.sq=loofit$adj.r.sq,
                           looRMSE=loofit$looRMSE,
                           looMdAE=loofit$looMdAE)
  return(ret)
}

resloo = list()

dat=data
dat[[resp]][dat$Year%in%rmyr]=NA
dat$resp = dat[[resp]]
m0 = gam(resp ~ 1, data=dat)
m0$data = dat[,c("Year","resp")]
res = list(`null intercept`=m0)
modname = "null intercept"
resloo[[modname]] = retloodf(m0, modname)
cat("\n", modname)

  dat$cov1=dat[[str_replace(resp,"0","1")]]
  m0 = gam(resp ~ offset(cov1), data=dat)
  m0$data = dat[,c("Year","resp","cov1")]
  modname = "null offset w intercept"
  res[[modname]] = m0
  resloo[[modname]] = retloodf(m0, modname)
  cat("\n", modname)
  
  m0 = lm(resp ~ -1 + offset(cov1), data=dat)
  m0$data = dat[,c("Year","resp","cov1")]
  modname = "null offset only"
  res[[modname]] = m0
  resloo[[modname]] = retloodf(m0, modname)
cat("\n", modname)
 
for(val in tests){
  if(length(val)==1){
  dat$cov1=dat[[covnames[val[1]]]]
  m0 = gam(resp ~ cov1, data=dat)
  m0$data = dat[,c("Year","resp", "cov1")]
  modname = paste0("lin(", modnames[val[1]],")")
  res[[modname]] = m0
  resloo[[modname]] = retloodf(m0, modname)
  cat("\n", modname)

  m0 = gam(resp ~ s(cov1, sp=0.6), data=dat)
  m0$data = dat[,c("Year","resp", "cov1")]
  modname = paste0("gam(", modnames[val[1]],")")
  res[[modname]] = m0
  resloo[[modname]] = retloodf(m0, modname)
  cat("\n", modname)

  }else{
    dat$cov1=dat[[covnames[val[1]]]]
    dat$cov2=dat[[covnames[val[2]]]]
    m0 = gam(resp ~ cov1 + cov2, data=dat)
    m0$data = dat[,c("Year","resp", "cov1", "cov2")]
    modname=paste0("lin(", modnames[val[1]], "), lin(", modnames[val[2]], ")")
    res[[modname]] = m0
    resloo[[modname]] = retloodf(m0, modname)
    cat("\n", modname)

    m0 = gam(resp ~ s(cov1,sp=0.6) + s(cov2,sp=0.6), data=dat)
    m0$data = dat[,c("Year","resp", "cov1", "cov2")]
    modname=paste0("gam(", modnames[val[1]], "), gam(", modnames[val[2]], ")")
    res[[modname]] = m0
    resloo[[modname]] = retloodf(m0, modname)
    cat("\n", modname)
  }
}

retloodfmarss <- function(modlist, inits.list, modname, dat){
pred <- pred.smooth <- aics <- aiccs <- loos <- loomds <- c()
for(t in 1:length(dat$resp)){
  tmp <- dat$resp; tmp[t]=NA
  fit <- MARSS(tmp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
  pred <- c(pred, fitted(fit, type="ytt1", output="matrix")[t])
  pred.smooth <- c(pred.smooth, fitted(fit, type="ytT", output="matrix")[t])
  aics <- c(aics, AIC(fit))
  aiccs <- c(aiccs, fit$AICc)
  err <- tmp - fitted(fit, type="ytt1", output="matrix")[1,]
  loos <- c(loos, sqrt(mean(err^2, na.rm=TRUE)))
  loomds <- c(loomds, median(abs(err)))
  cat(t, " ")
}
ret = list(model=modname, 
                         data=dat[,c("Year","resp")], 
                         pred=pred, pred.smooth=pred.smooth,
                         AIC=aics,
                         AICc=aiccs,
                         adj.r.sq=NULL,
                         looRMSE=loos,
                         looMdAE=loomds)
return(ret)
}


#dlm intercept
inits.list = list(x0=matrix(dat$resp[1]))
modlist <- list(U=matrix(0))
m0 <- MARSS(dat$resp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
m0$data = dat[,c("Year","resp")]
modname="dlm(intercept)"
res[[modname]] = m0
cat("\n", modname)
resloo[[modname]] = retloodfmarss(modlist, inits.list, modname, m0$data)

#dlm intercept + slope
Zt = array(1, dim=c(1,2,length(dat$resp)))
dat$cov1=1:length(dat$resp)
Zt[1,2,] = 1:length(dat$resp)
R=matrix("r")
Q=matrix(list(0),2,2); diag(Q)=c("q1","q2") 
inits.list = list(x0=matrix(c(dat$resp[1],0), nrow=2))
modlist = list(Z=Zt, Q=Q, U=matrix(0,1,2), B=diag(1,2), A=matrix(0), R=R)
m0 <- MARSS(dat$resp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
m0$data = dat[,c("Year","resp","cov1")]
modname="dlm(intercept, slope)"
res[[modname]] = m0
cat("\n", modname)
resloo[[modname]] = resloo[[modname]] = retloodfmarss(modlist, inits.list, modname, m0$data)

#dlm with time-varying multiplier on Oct-Mar t-1 catch
dat$cov1=dat[[covnames[1]]]
Zt = array(NA, dim=c(1,1,length(dat$cov1)))
Zt[1,1,] = dat$cov1
A=matrix("intercept")
R=matrix("r")
Q=matrix("q") 
inits.list = list(x0=matrix(c(0), nrow=1))
modlist = list(Z=Zt, Q=Q, U=matrix(0), B=diag(1), A=A, R=R)
m0 <- MARSS(dat$resp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
m0$data = dat[,c("Year","resp","cov1")]
modname = paste0("dlm(", modnames[1],")")
res[[modname]] = m0
cat("\n", modname)
resloo[[modname]] = resloo[[modname]] = retloodfmarss(modlist, inits.list, modname, m0$data)

#dlm with Jul-Sep t-1 catch
dat$cov1=dat[[covnames[2]]]
Zt = array(NA, dim=c(1,1,length(dat$cov1)))
Zt[1,1,] = dat$cov1
A=matrix("intercept")
R=matrix("r")
Q=matrix("q") #fix so doesn't go to zero
inits.list = list(x0=matrix(c(0), nrow=1))
modlist = list(Z=Zt, Q=Q, U=matrix(0), B=diag(1), A=A, R=R)
m0 <- MARSS(dat$resp, model=modlist, silent=TRUE, method="BFGS", inits=inits.list)
m0$data = dat[,c("Year","resp", "cov1")]
modname = paste0("dlm(", modnames[2],")")
res[[modname]] = m0
cat("\n", modname)
resloo[[modname]] = resloo[[modname]] = retloodfmarss(modlist, inits.list, modname, m0$data)

return(list(Fitted=res, LooPred=resloo))
}
```

```{r child = 'setup.Rmd'}
```


```{r}
library(SardineForecast)
# source("setup.Rmd")
dforig=data.frame(Year=respdat$Year, 
                  spawners0=respdat$spawners0, spawners1=respdat$spawners1, spawners2=respdat$spawners2, nspawners1=respdat$nspawners1, 
                  nspawners2=respdat$nspawners2)
dforig <- na.omit(dforig)
dforig.np=data.frame(Year=respdat$Year, 
                  nspawners0=respdat$nspawners0, spawners1=respdat$spawners1, spawners2=respdat$spawners2, nspawners1=respdat$nspawners1, 
                  nspawners2=respdat$nspawners2)
dforig.np <- na.omit(dforig.np)
FittedLooPred1956 <- fits(data=dforig, resp="spawners0")
FittedLooPred.np1956 <- fits(data=dforig.np, resp="nspawners0")
FittedLooPred1984 <- fits(data=dat.spawners, resp="spawners0")
FittedLooPred.np1984 <- fits(data=dat.nonspawners, resp="nspawners0")
save(FittedLooPred1956, FittedLooPred.np1956, FittedLooPred1984, FittedLooPred.np1984, file="FittedLooPred.Rdata")
```